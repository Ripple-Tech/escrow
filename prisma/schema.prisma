// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Plan {
  FREE
  PRO
}

// Auth Models

model Account {
  id                 String   @id @default(uuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String?
  access_token       String?
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String?
  session_state      String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

enum UserRole {
  ADMIN
  USER
}

model User {
  id                 String               @id @default(uuid())
  email              String?              @unique
  emailVerified      DateTime?
  phonenumber        String?
  name               String?
  surname            String?
  username           String?              @unique
  image              String?
  password           String?
  role               UserRole             @default(USER)
  apiKey             String               @unique @default(cuid())
  isGuest            Boolean              @default(false)
  isTwoFactorEnabled Boolean              @default(false)
  balance            Int                  @default(0)

   // Relations
  paystackCustomer PaystackCustomer?  @relation(fields: [paystackCustomerId], references: [id])
  paystackCustomerId String?          @unique

  buyerLockedFunds  Lockedfund[] 
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt

  isChatDelayed      Boolean              @default(false)
  isChatEnabled Boolean @default(true)
  isChatFollowersOnly Boolean @default(false)
  following     Follow[] @relation("UserFollowing")
  followedBy    Follow[] @relation("UserFollowedBy")
  blocking      Block[]  @relation("Blocking")
  blockedBy     Block[]  @relation("BlockedBy")
  // Auth and security relations
  accounts           Account[]
  twoFactorConfirmation TwoFactorConfirmation?
  transactions       Transaction[]

  // Escrow relations
  createdEscrows     Escrow[]             @relation("CreatorEscrows")
  buyerEscrows       Escrow[]             @relation("BuyerEscrows")
  sellerEscrows      Escrow[]             @relation("SellerEscrows")
  sentEscrows        Escrow[]             @relation("SentEscrows")

  receivedEscrows    Escrow[]             @relation("ReceivedEscrows")

  // Opposite relation for Escrow.user
  escrows            Escrow[]             @relation("UserEscrows")

  // Opposite relation for EscrowActivity.user
  escrowActivities   EscrowActivity[]
  conversations Conversation[]  @relation("ConversationUsers")
  seenMessages  Message[]       @relation("SeenMessages")

  messages      Message[]
  @@index([email, apiKey])
}

model PaystackCustomer {
  id            String                  @id @default(uuid())
  customerCode  String                  @unique // e.g. CUS_xnxdt6s1zg1f4nx
  email         String
  firstName     String?
  lastName      String?
  phone         String?
  identified    Boolean                 @default(false)
  // raw payload snapshots (optional but handy for debugging)
  meta          Json?
  createdAt     DateTime                @default(now())
  updatedAt     DateTime                @updatedAt

  // Relations
  user          User?                   @relation
  dedicatedAccount PaystackDedicatedAccount?

  @@index([email])
  @@index([customerCode])
}

model PaystackDedicatedAccount {
  id               String     @id @default(uuid())

  // Core DVA info from Paystack "Create Dedicated Virtual Account"
  // Fields vary by bank; keep flexible but strongly typed
  accountNumber    String     @unique
  bankName         String
  bankCode         String?
  // Some responses include assigned account_name or brand "Managed Account"
  accountName      String?
  // Paystack sometimes labels channel "dedicated_nuban"
  channel          String?    // "dedicated_nuban"
  // Receiver bank account number in webhook samples (store for reference)
  receiverAccount  String?
  receiverBank     String?

  // Lifecycle
  status           String     @default("active") // active | pending | disabled
  assignedAt       DateTime?
  // Raw payload snapshot for auditing
  raw              Json?

  // Relation back to PaystackCustomer (1â€“1)
  paystackCustomer   PaystackCustomer @relation(fields: [paystackCustomerId], references: [id])
  paystackCustomerId String           @unique

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  @@index([accountNumber])
}

model Follow {
  id           String   @id @default(uuid())
  followerId   String
  followingId  String
  follower     User     @relation(name: "UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following    User     @relation(name: "UserFollowedBy", fields: [followingId], references: [id], onDelete: Cascade)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Block {
  id          String   @id @default(uuid())
  blockerId   String
  blockedId   String
  blocker     User     @relation(name: "Blocking", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked     User     @relation(name: "BlockedBy", fields: [blockedId], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// Security and password management models
model VerificationToken {
  id      String   @id @default(uuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model PasswordResetToken {
  id      String   @id @default(uuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorToken {
  id      String   @id @default(uuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
}

model TwoFactorConfirmation {
  id     String @id @default(uuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
}



enum EscrowStatus {
  PENDING
  IN_PROGRESS
  RELEASED
  CANCELLED
  COMPLETED
}

enum EscrowRole {
  SELLER
  BUYER
}

enum EscrowSource {
  INTERNAL
  API
}

enum EscrowInvitationStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

enum LogisticsOption {
  NO
  PICKUP
  DELIVERY
}
enum DeliveryStatus {
PENDING
DELIVERED
}
enum Currency {
  NGN
  USD
  GHS
}

model Escrow {
  id            String       @id @default(cuid())
  productName   String
  description   String?
  amount        Decimal
  currency      Currency
  status        EscrowStatus @default(PENDING)
  role          EscrowRole
  lockedfund   Lockedfund?
  sender        User         @relation("SentEscrows", fields: [senderId], references: [id])
  senderId      String
  senderEmail   String?
  receiver      User?        @relation("ReceivedEscrows", fields: [receiverId], references: [id])
  receiverId    String?
  receiverEmail String?
  buyer         User?        @relation("BuyerEscrows", fields: [buyerId], references: [id])
  buyerId       String?
  seller        User?        @relation("SellerEscrows", fields: [sellerId], references: [id])
  sellerId      String?
  creator       User         @relation("CreatorEscrows", fields: [creatorId], references: [id])
  creatorId     String
  user         User?        @relation("UserEscrows", fields: [userId], references: [id])
  userId       String?
  source            EscrowSource           @default(INTERNAL)
  deliveryStatus    DeliveryStatus @default(PENDING)
  invitationStatus  EscrowInvitationStatus @default(PENDING)
  invitedRole       EscrowRole?
  logistics     LogisticsOption @default(NO)
  photoUrl      String?
  color         String?
  category      String?
  quantity      Int?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  activities    EscrowActivity[]

   conversation     Conversation?
  
//  @@unique([id, senderId])
}

// Transaction Models
enum TransactionType {
  DEPOSIT
  WITHDRAW
  TRANSFER
  FEE
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
}
enum TransactionDirection {
  DEBIT  
  CREDIT  
}

model Transaction {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id])

  type      TransactionType
  status    TransactionStatus @default(PENDING)
  reference String            @unique
  amount    Float
  currency  Currency
  direction TransactionDirection  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model EscrowActivity {
  id        String   @id @default(uuid())
  escrowId  String
  userId    String
  action    String   // e.g. CREATED, ACCEPTED, RELEASED
  createdAt DateTime @default(now())

  escrow    Escrow   @relation(fields: [escrowId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
}

model Lockedfund {
  id        String   @id @default(cuid())
  escrowId  String   @unique
  buyerId   String
  amount    Decimal
  createdAt DateTime @default(now())
  released  Boolean  @default(false)

  // Relations
  escrow Escrow @relation(fields: [escrowId], references: [id])
  buyer  User   @relation(fields: [buyerId], references: [id])
}

model Conversation {
  id            String      @id @default(uuid())
  createdAt     DateTime    @default(now())
  lastMessageAt DateTime    @default(now())
  escrowId      String?     @unique
  escrow        Escrow?     @relation(fields: [escrowId], references: [id], onDelete: Cascade)
  messagesIds   String[]
  userIds       String[]
  users         User[]      @relation("ConversationUsers")
  messages      Message[]
}

model Message {
  id             String       @id @default(uuid())
  body           String?
  image          String?
  createdAt      DateTime     @default(now())
  seenIds        String[]
  seen           User[]       @relation("SeenMessages")
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  senderId       String
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
}


